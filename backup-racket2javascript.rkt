#lang racket

(provide javascript javascript-str javascript-statement javascript-expression)

(define-syntax (defmodel stx)
  (syntax-case stx ()
    [(def (name file render-view) expr ...)
     (syntax/loc stx
       (javascript '(defmodel (name) expr ...)))]
    [(def (name file) expr ...)
     (quasisyntax/loc stx
       (def (name file render-view) expr ...))]
    [(def (name) expr ...)
     (quasisyntax/loc stx
       (def (name #,(symbol->string (syntax->datum #'name))) expr ...))]))


(define-syntax (deftikz stx)
  (syntax-case stx ()
    [(def (name) expr ...)
     (quasisyntax/loc stx
       (def (name #,(symbol->string (syntax->datum #'name)))
         expr ...))]
    [(def (name file) expr ...)
     (quasisyntax/loc stx
       (defmodel (name file identity #;tikz<-entidades)
         expr ...))]))
#;
(define-syntax (deffilm stx)
  (syntax-case stx ()
    [(def (name file) expr ...)
     (syntax/loc stx
       (let ()
         (reset)
         #;#;
         (start-film file)
         (let ()
           expr ...)))]
    [(def (name) expr ...)
     (quasisyntax/loc stx
       (def (name #,(symbol->string (syntax->datum #'name))) expr ...))]))

(define-syntax-rule (deffilm . body) (javascript '(deffilm . body)))
(define-syntax-rule (film name . body) (javascript '(film name . body)))

#;
(define-syntax (unless-backends stx)
  (syntax-case stx ()
    [(_ (name ...) body ...)
     (with-syntax ([(name-strs ...)
                    (map (lambda (stx)
                           (symbol->string (syntax-e stx)))
                         (syntax-e #'(name ...)))])
       (syntax/loc stx
         (if (member (current-backend-name) '(name-strs ...))
             (void)
             (begin body ... (void)))))]))

(define-syntax-rule (unless-backends . body) (void))
(define-syntax-rule (pylet . body) (javascript-statement '(begin (let . body) (void))))
(define-syntax-rule (pydefine . body) (javascript-statement '(begin (define . body) (void))))
(define-syntax-rule (py: . body) (void))
(define-syntax-rule (py#%app . body) (javascript-statement '(begin body (void))))
(define-syntax-rule (pyset! . body) (javascript-statement '(begin (set! . body) (void))))
(define-syntax-rule (pyprovide . body) (void))
(define-syntax-rule (pydefine-syntax . body) (void))

(provide (rename-out [pylet let] [pydefine define] [py: :] [py#%app #%app] [pyset! set!]
                     [pyprovide provide] [pydefine-syntax define-syntax])
         defmodel deftikz deffilm film unless-backends)

(define reserved-words
  '(and       del       from      not       while    
              as        elif      global    or        with     
              #;assert    else      if        pass      yield    
              break     except    import    print              
              class     exec      in        raise              
              continue  finally   is        return             
              def       for       lambda    try))

(define renamed-variables
  (make-parameter '((immediate-mode? . immediate_mode)
                    (string-length . len)
                    (string-append . +)
                    (string% . %)
                    (expt . pow)
                    (define . def)
                    (= . ==)
                    (set! . =)
                    (if . if)
                    (and . and)
                    (or . or)
                    (not . not)
                    (%com-omit . None)
                    (truncate . trunc)
                    (ceiling . ceil)
                    (exact-floor . floor)
                    (exact-round . round)
                    (exact-ceiling . ceil)
                    (random-seed! . set_random_seed)
                    (random-integer-range . random_range)
                    (error . RuntimeError)
                    (+x . add_x)
                    (+y . add_y)
                    (+z . add_z)
                    (+xy . add_xy)
                    (+xz . add_xz)
                    (+yz . add_yz)
                    (+xyz . add_xyz)
                    (+pol . add_pol)
                    (+cyl . add_cyl)
                    (+sph . add_sph)
                    (-vx . -vx)
                    (-vy . -vy)
                    (-vz . -vz)
                    (? . ?)
                    (intermediate-point . intermediate_loc)
                    (loc-from-o-n . loc_from_o_vz)
                    (surface . surface_from)
                    (spline* . spline_tangents)
                    (length . len)
                    (random-integer . random)
                    (as-list . list)
                    (as-tuple . tuple)
                    (sequence->list . list)
                    (real->double-flonum . float))))

(define (javascript-name name)
  (or (dict-ref (renamed-variables) name #f)
      (let ((str (symbol->string name)))
        (cond ((char=? (string-ref str 0) #\_) ;This is from scribble
               (substring str 1))
              ((char=? (string-ref str 0) #\%)
               (string-append
                "rh."
                (string-replace
                 (string-titlecase (substring str 1))
                 "-" "")))
              ((char=? (string-ref str (- (string-length str) 1)) #\?)
               (string-append
                "is_"
                (string-replace (substring str 0 (- (string-length str) 1))
                                "-" "_")))
              ((member name reserved-words)
               (string-append "_" str))
              (else
               (let ((replacements
                      '(#;("-p" "np")
                        ("=" "equal_")
                        ("+p" "pp")
                        ("<-" "_from_")
                        ("?" "P")
                        ("!" "_set")
                        ("-" "_")
                        ("/" "_div_")
                        ("*" "_mul_")
                        ("+" "_add_"))))
                  (for ((repl (in-list replacements)))
                    (set! str (string-replace str (first repl) (second repl))))
                  str))))))

(define (javascript-format-str str (i 0))
  (if (or (string-contains? str "~a")
          (string-contains? str "~A"))
      (javascript-format-str
       (string-replace str #rx"~[aA]" (format "{~A}" i) #:all? #f)
       (+ i 1))
      (string-replace str "~%" "\n")))

(define (advance n)
  (for ((i n))
    (display " ")))

(define (unparse-parameter param)
  (match param
    (`(,param : ,type ,init)
     (display (javascript-name param))
     (display "=")
     (javascript-expression init)
     param)
    (`(,param : ,type)
     (display (javascript-name param))
     param)
    (`(,param ,init)
     (display (javascript-name param))
     (display "=")
     (javascript-expression init)
     param)
    (else
     (display (javascript-name param))
     param)))

(define (javascript-parameters params)
  (cond ((null? params)
         (list))
        (else
         (cons (unparse-parameter (car params))
               (for/list ((param (cdr params)))
                 (display ", ")
                 (unparse-parameter param))))))

(define (binding-var binding)
  (match binding
    (`(,var ,init)
     var)
    (`(,var : ,_ ,init)
     var)))

(define (binding-val binding)
  (match binding
    (`(,var ,init)
     init)
    (`(,var : ,_ ,init)
     init)))

(define locals (make-parameter (list)))

(define (renamed-variable var)
  (let ((str (symbol->string var)))
    (let ((new-var (string->symbol (string-append str "0"))))
      (if (member var (locals))
          (renamed-variable new-var)
          new-var))))

(define include-return? (make-parameter #t))

(define (javascript-statement stmt [indent 0] [return? #f])
  (match stmt
    (`(void) (void))
    ((or `(define #:forall ,_ (,name . ,params) : ,_ . ,body)
         `(define (,name . ,params) : ,_ . ,body)
         `(define (,name . ,params) . ,body))
     (advance indent)
     (printf "function ~A(" (javascript-name name))
     (let ((params
            (if (symbol? params)
                (begin
                  (printf "*~A" (javascript-name params))
                  (list params))
                (javascript-parameters params))))
       (printf "){~%")
       (parameterize ((locals (append (locals) params)))
         (javascript-statements body (+ indent 4) (include-return?))))
       (printf "\n}")
     #;(newline))
    ((or `(define ,name ,init)
         `(define ,name : ,_ ,init))
     (advance indent)
     (printf "~A = " (javascript-name name))
     (javascript-expression init))
    (`(when ,test . ,stmts)
     (advance indent)
     (printf "if(")
     (javascript-expression test)
     (printf "){~%")
     (javascript-statements stmts (+ indent 4))
     (printf "\n}")
    )
    (`(unless ,test . ,stmts)
     (advance indent)
     (printf "if(")
     (javascript-expression `(not ,test))
     (printf "){~%")
     (javascript-statements stmts (+ indent 4))
     (printf "\n}")
     )
    (`(set! ,name ,init)
     (advance indent)
     (javascript-expression name)
     (printf " = " )
     (javascript-expression init))
    ((or `(let ,(? symbol? rec) : ,_ ,bindings . ,stmts)
         `(let ,(? symbol? rec) ,bindings . ,stmts))
     (javascript-statements
      `((define (,rec ,@(map binding-var bindings)) . ,stmts)
        (,rec ,(map binding-val bindings)))
      indent
      return?))
     (`(let ,bindings . ,stmts)
      (if (null? bindings)
         (javascript-statements stmts indent)
         (begin
           (advance indent)
           (let ((vars (map binding-var bindings))
                 (vals (map binding-val bindings)))
             (javascript-parameters vars)
             (printf " = ")
             (javascript-expressions vals))
           (newline)
           (javascript-statements stmts indent return?))))
    (`(let* ,bindings . ,stmts)
     (for ((binding bindings))
       (advance indent)
       (match binding
         ((or `(,var ,val)
              `(,var : ,_ ,val))
          (display (javascript-name var))
          (printf " = ")
          (javascript-expression val)))
       (newline))
     (javascript-statements stmts indent return?))
    (`(let-values ,bindings . ,stmts)
     (if (null? bindings)
         (javascript-statements stmts indent)
         (begin
           (advance indent)
           (for ((binding bindings))
             (let ((vars (first binding))
                   (val (second binding)))
               (javascript-parameters vars)
               (printf " = ")
               (javascript-expression val)
               (newline)))
           (javascript-statements stmts indent return?))))
    (`(parameterize ,bindings . ,stmts)
     (javascript-statement `(let ,bindings . ,stmts) indent))
    (`(if ,test ,conseq ,altern)
     (advance indent)
     (printf "if(")
     (javascript-expression test)
     (printf "){~%")
     (javascript-statement conseq (+ indent 4) return?)
     (printf "}")
     (newline)
     (advance indent)
     (printf "}else{~%")
     (javascript-statement altern (+ indent 4) return?)
     (printf "}")
     )
    (`(cond ,clause . ,clauses)
     (advance indent)
     (match clause
       (`(,test . ,stmts)
        (printf "if(")
        (javascript-expression test)
        (printf "){~%")
        (javascript-statements stmts (+ indent 4) return?)
        (printf "}")
        ))
     (for ((clause clauses))
       (newline)
       (advance indent)
       (match clause
         (`(else . ,stmts)
          (printf "else{~%")
          (javascript-statements stmts (+ indent 4) return?))
         (`(,test . ,stmts)
          (printf "}else if(")
          (javascript-expression test)
          (printf "){~%")
          (javascript-statements stmts (+ indent 4) return?)
          (printf "}")
          )
         (`...
          (printf "...")))))
    (`(begin ,stmt . ,stmts)
     (javascript-statement stmt indent)
     (newline)
     (javascript-statements stmts indent return?))
    (`(begin0 ,stmt . ,stmts)
     (javascript-statement `(let ((res ,stmt)) ,@stmts res) indent return?))
    (`(for-each ,f ,l)
     (javascript-statement `(for ([e ,l]) (,f e)) indent return?))
    (`(pass)
     (advance indent)
     (printf "pass"))
    ((or `(for : ,_ ([,var : ,_ ,expr]) . ,body)
         `(for ([,var ,expr]) . ,body)
         `(for : ,_ ([,var ,expr]) . ,body)
         `(for ([,var : ,_ ,expr]) . ,body))
     (advance indent)
     (printf "for(")
     (if (cons? var)
         (javascript-expressions var)
         (javascript-expression var))
     (printf " in ")
     (if (number? expr)
       (javascript-expression `(range ,expr))
       (javascript-expression expr))
     (printf "){~%")
     (javascript-statements body (+ indent 4)))
    ((or `(for : ,_ ,params . ,body)
         `(for ,params . ,body))
     (let ((params (for/list ((param params))
                     (match param
                       ((or `(,param : ,_ ,init) `(,param ,init))
                        param))))
           (inits (for/list ((param params))
                     (match param
                       ((or `(,param : ,_ ,init) `(,param ,init))
                        init)))))
       (when (ormap (lambda (param) (member (javascript-name param) (locals))) params)
         (error "Repeated variable" params))
       (javascript-statement `(for ((,params (zip . ,inits))) . ,body) indent return?)))
    (`(translating ,e1 ,e2 ,e3 . ,body)
     (javascript-statement
      `(with (parameter current-cs (translated-cs ,e1 ,e2 ,e3)) . ,body)
      indent
      return?))
    (`(z-rotating ,e . ,body)
     (javascript-statement
      `(with (parameter current-cs (z-rotated-cs ,e)) . ,body)
      indent
      return?))
    (`(jsnewline)
     (newline))
    (else
     (match stmt
       (`(error . ,_)
        (javascript-maybe-indent-expression "raise " stmt indent))
       (else
        (javascript-maybe-indent-expression (if return? "return " "") stmt indent))))))


(define (javascript-statements stmts indent [return? #f])
  (if (null? stmts)
      (javascript-statement `(pass) indent)
      (let ((first? #t))
        (for ((stmt (drop-right stmts 1)))
          (match stmt
            (`(show ,str ,expr . ,exprs)
             #t)
            (`(: . ,_) ;type declaration
             #t)
            (else
             (cond (first?
                    (javascript-statement stmt indent)
                    (set! first? #f))
                   (else
                    (newline)
                    (javascript-statement stmt indent))))))
        (unless first? (newline))
        (javascript-statement (last stmts) indent return?))))

#;#;
(require racket/trace)
(trace unparse-statement unparse-statements)

(define (+op->op op)
  (string->symbol
   (string-append "v" (substring (symbol->string op) 1))))

(define (operator-precedence op)
  (cdr
   (assoc op
          '(((lambda) . 0)
            ((if) . 1)
            ((or) . 2)
            ((and) . 3)
            ((not) . 4)
            ((in is < <= > >= == eq?) . 5)
            ((bit-or) . 6)
            ((bit-xor) . 7)
            ((bit-and) . 8)
            ((shiftl shiftr) . 9)
            ((+) . 9.5) ;To deal with 1-(2+3)
            ((+ -) . 10)
            ((*) . 10.5) ;To deal with 1/(2*3)
            ((* / // %) . 11)
            ((string%) . 11.5) ;To avoid type contagion
            ((unary+ unary- unary~) . 12)
            ((**) . 13)
            ((index call attribute) . 14)
            ((tuple list dict) . 15))
          member)))

(define (unparsable form)
  (printf "\"\"\"~%")
  (pretty-print form)
  (printf "\"\"\"~%"))

(define-syntax-rule
  (maybe-paren (op op-precedence precedence) e ...)
  (let ((op-precedence (operator-precedence op)))
    (let ((paren? (> precedence op-precedence)))
      (when paren? (display "("))
      e ...
      (when paren? (display ")")))))

(define operator-translations
  '((p+v . +)
    (v+v . +)
    (p-v . -)
    (v-v . -)
    (p-p . -)
    (v/r . /)
    (v*r . *)
    (+c . +)
    (-c . -)
    (*c . *)
    (/c . /)
    (remainder . %)
    (modulo . %)
    (quotient . //)
    (expt . **)
    (eq? . is)
    (append . +)
    (list-ref . index)
    (vector-ref . index)
    (string-ref . index)
    (string-append . +)))


;;To take into account the need for indentation in function calls
(define javascript-line-limit 80)
(define break-line? (make-parameter #f))

(define (javascript-maybe-indent-expression start expr indent)
  (let ((so (open-output-string)))
    (port-count-lines! so)
    (parameterize ((current-output-port so)
                   (break-line? #f))
      (advance indent)
      (printf start)
      (javascript-expression expr))
    (let ((str (get-output-string so)))
      (if (> (+ (string-length str) indent) javascript-line-limit)
          (let ((so (open-output-string)))
            (port-count-lines! so)
            (parameterize ((current-output-port so)
                           (break-line? #t))
              (advance indent)
              (printf start)
              (javascript-expression expr))
            (display (get-output-string so)))
          (display str)))))

(define (javascript-call fn args)
  (javascript-expression fn (operator-precedence 'call))
  (display "(")
  (cond ((null? args)
         )
        ((break-line?)
         (let-values (((line column pos) (port-next-location (current-output-port))))
           (parameterize ((break-line? #f)) (javascript-expression (first args)))
           (for ((arg (rest args)))
             (display ",")
             (newline)
             (advance column)
             (parameterize ((break-line? #f)) (javascript-expression arg)))))
        (else
         (javascript-expressions args)))
  (display ")"))

(define (javascript-expression e [precedence 0])
  (define (rec e) (javascript-expression e precedence))
  (match e
    (`(error ',name ,str . ,args)
     (rec `(error (format ,(string-append "~A: " str) ,(javascript-name name) . ,args))))
    (`(foldl ,f ,i ,l)
     (rec `(reduce ,f ,l ,i)))
    (`(1- ,e)
     (rec `(- ,e 1)))
    (`(add1 ,e)
     (rec `(+ ,e 1)))
    (`(zero? ,e)
     (rec `(= ,e 0)))
    (`(sgn ,e)
     (rec `(copysign 1 ,e)))
    (`(cx ,p)
     (rec `(attribute ,p x)))
    (`(cy ,p)
     (rec `(attribute ,p y)))
    (`(cz ,p)
     (rec `(attribute ,p z)))
    (`(cross-c ,v0 ,v1)
     (rec `(attribute ,v0 (cross ,v1))))
    (`(v*v ,v0 ,v1)
     (rec `(attribute ,v0 (cross ,v1))))
    (`(v.v ,v0 ,v1)
     (rec `(attribute ,v0 (dot ,v1))))
    (`(dot-c ,v0 ,v1)
     (rec `(attribute ,v0 (dot ,v1))))
    (`(string-join ,strs ,el)
     (rec `(attribute ,el (join ,strs))))
    (`(in-range . ,args)
     (rec `(range . ,args)))
    (`(in-division . ,args)
     (rec `(division . ,args)))
    (`(,(or `in-period `period) . ,args)
     (rec `(division ,@args #f)))
    (`(in-list ,arg)
     (rec arg))
    (`(values . ,args)
     (printf "(")
     (javascript-expressions args)
     (printf ")"))
    (`(splice-arg ,arg)
     (display "*")
     (javascript-expression arg))
    (`(apply ,fn . ,args)
     (rec
      `(,fn ,@(drop-right args 1) (splice-arg ,(last args)))))
    (`(if ,test ,conseq ,altern)
     (maybe-paren ('if op-precedence precedence)
       (javascript-expression conseq (+ 0.5 op-precedence))
       (display " if ")
       (javascript-expression test (+ 0.5 op-precedence))
       (display " else ")
       (javascript-expression altern (+ 0.5 op-precedence))))
    (`(cond (else ,conseq))
     (rec conseq))
    (`(cond (,test ,conseq) . clauses)
     (rec
      `(if ,test ,conseq (cond . clauses))))
    (`(andmap ,f ,l)
     ;this is for Python3
     (rec `(all (map ,f ,l))))
    (`(ormap ,f ,l)
     ;this is for Python3
     (rec `(any (map ,f ,l))))
    (`(show ,str ,expr)
     (rec expr))
    (`(inst ,expr . ,_)
     (rec expr))
    (`(ann ,expr ,_)
     (rec expr))
    ((or `(= . ,args)
         `(=c? . ,args))
     (rec `(== . ,args)))
    (`(atan ,e0 ,e1)
     (rec `(atan2 ,e0 ,e1)))
    (`(list . ,args)
     (display "[")
     (javascript-expressions args)
     (display "]"))
    (`(cdr (drop-right ,lst ,n))
     (rec `(index ,lst (list-range 1 (- ,n)))))
    (`(sublist ,lst ,i ,e)
     (rec `(index ,lst (list-range ,i ,e))))
    (`(reverse ,lst)
     (rec `(reversed ,lst)))
    (`'()
     (rec `(list)))
    (`'(,first . ,rest)
     (rec `(list ,first . ,rest)))
    (`(cons ,e ,lst)
     (rec `(append (list ,e) ,lst)))
    (`(null? (cdr ,expr))
     (rec `(= (len ,expr) 1)))
    (`(null? (cddr ,expr))
     (rec `(= (len ,expr) 2)))
    (`(null? ,expr)
     (rec `(= ,expr (list))))
    ((or `(car ,lst)
         `(first ,lst))
     (rec `(index ,lst 0)))
    (`(last ,lst)
     (rec `(index ,lst -1)))
    (`(cdr ,lst)
     (rec `(index ,lst |1:|)))
    (`(caar ,lst)
     (rec `(car (car ,lst))))
    ((or `(cadr ,lst)
         `(second ,lst))
     (rec `(index ,lst 1)))
    ((or `(caddr ,lst)
         `(third ,lst))
     (rec `(index ,lst 2)))
    (`(cadddr ,lst)
     (rec `(index ,lst 3)))
    (`(cdar ,lst)
     (rec `(cdr (car ,lst))))
    (`(cddr ,lst)
     (rec `(index ,lst (list-range 2 #f))))
    (`(caadr ,lst)
     (rec `(car (cadr ,lst))))
    (`(cadar ,lst)
     (rec `(car (cdar ,lst))))
    (`(cdddr ,lst)
     (rec `(index ,lst (list-range 3 #f))))
    (`(cddddr ,lst)
     (rec `(index ,lst (list-range 4 #f))))
    (`(cadadr ,lst)
     (rec `(cadr (cadr ,lst))))
    (`(index ,lst ,n)
     (maybe-paren ('index op-precedence precedence)
       (javascript-expression lst op-precedence))
     (printf "[")
     (javascript-expression n)
     (printf "]"))
    (`(list-range ,from ,to)
     (printf "range(")
     (when from
       (javascript-expression from))
     (when to
       (javascript-expression to))
     (printf ")")
       )
    (`(drop ,lst ,n)
     (rec `(index ,lst (list-range ,n #f))))
    (`(drop-right ,lst ,n)
     (rec `(index ,lst (list-range #f (- ,n)))))
    (`(take ,lst ,n)
     (rec `(index ,lst (list-range 0 ,n))))
    (`(take-right ,lst ,n)
     (rec `(index ,lst (list-range (- ,n) -1))))
    (`(remove ,e ,lst)
     (printf "[_e for _e in ")
     (javascript-expression lst)
     (printf " if _e != ")
     (javascript-expression e)
     (printf "]"))
    (`(memf ,p ,l)
     ;;not entirely equivalent
     (rec `(as-list (filter ,p ,l))))
    #;(`(radianos<-graus ,arg)
     (unparse-expression `(radians ,arg)))
    (`(real->decimal-string ,r)
     (rec `(real->decimal-string ,r 2)))
    (`(real->decimal-string ,r ,places)
     (rec `(string% ,(format "%.~Af" places) ,r)))
    ;unary operators
    (`(,(and (or `not `- `+) op) ,arg)
     (let ((unary-op (dict-ref '((+ . unary+) (- . unary-) (~ . unary~)) op op)))
       (maybe-paren (unary-op op-precedence precedence)
         (let ((space? (member op '(not))))
           (display op)
           (when space? (display " "))
           (javascript-expression arg op-precedence)))))
    (`(sqr ,x)
     (rec `(expt ,x 2)))
    (`(/ ,x -2)
     (rec `(- (/ ,x 2))))
    (`(,(? (lambda (op) (dict-has-key? operator-translations op)) op) . ,args)
     (rec `(,(dict-ref operator-translations op) . ,args)))
    (`(,(? (lambda (op)
             (member op '(or and is ** * / // % + - < > <= >= == string%)))
           op)
       ,arg . ,args)
     (maybe-paren (op op-precedence precedence)
       (let ((space? (member op '(is + - < > <= >= == or and))))
         (javascript-expression
             arg
             (if (eq? op '**) ;associate from right to left
               (+ op-precedence 0.5)
               op-precedence))
         (for ((arg args))
           (when space? (display " "))
           (display (if (eq? op 'string%) '% op)) ;special case
           (when space? (display " "))
           (javascript-expression arg op-precedence)))))
    (`(,(and (or `+xyz `+xy `+xz `+yz `+x `+y `+z `+pol `+cyl `+sph) op) ,arg . ,args)
     (rec `(p+v ,arg (,(+op->op op) . ,args))))
    ((or `(lambda ,params ,expr)
         `(lambda ,params : ,_ ,expr))
     (maybe-paren ('lambda op-precedence precedence)
       (printf "function(")
       (javascript-parameters params)
       (printf "){ ")
       (javascript-expression expr))
       (printf "}")
       )
    (`(lambda ,params . ,exprs)
     (rec `(lambda ,params (last (list . ,exprs)))))
    (`(let ,bindings . ,stmts)
     (let ((vars (map binding-var bindings))
           (vals (map binding-val bindings)))
       (rec `((lambda ,vars . ,stmts) . ,vals))))
    (`(cast ,expr ,type)
     (rec expr))
    (`(begin . ,exprs)
     (rec `(last (list . ,exprs))))
    ;;This isn't OK when the body also uses the iteration variables 
#;    ((or `(for/list : ,_ (,(or `(,var0 ,init0) `(,var0 : ,_ ,init0))) (let (,(or `(,var1 ,init1) `(,var1 : ,_ ,init1))) ,body))
         `(for/list (,(or `(,var0 ,init0) `(,var0 : ,_ ,init0))) (let (,(or `(,var1 ,init1) `(,var1 : ,_ ,init1))) ,body)))
     (rec
      `(map (lambda (,var1) ,body)
            (for/list ((,var0 ,init0)) ,init1))))
    ((or `(for/list : ,_ ([,var : ,_ ,expr]) ,body)
         `(for/list ([,var ,expr]) ,body)
         `(for/list : ,_ ([,var ,expr]) ,body)
         `(for/list ([,var : ,_ ,expr]) ,body))
     (let ((vars (if (cons? var) var (list var))))
       (parameterize ((renamed-variables
                        (append (renamed-variables)
                                (map (lambda (var)
                                       (cons var (renamed-variable var)))
                                     (filter (lambda (var)
                                               (member var (locals)))
                                             vars)))))
         (printf "[")
         (javascript-expression body)
         (printf " for ")
         (javascript-expressions vars)
         (printf " in "))
       (javascript-expression expr)
       (printf "]")))
    ((or `(for/list : ,_ ,params . ,body)
         `(for/list ,params . ,body)
         `(for ,params . ,body))
     (let ((params (for/list ((param params))
                     (match param
                       ((or `(,param : ,_ ,init) `(,param ,init))
                        param))))
           (inits (for/list ((param params))
                     (match param
                       ((or `(,param : ,_ ,init) `(,param ,init))
                        init)))))
       (rec `(for/list ((,params (zip . ,inits))) . ,body))))
    (`(with-3d (,var) . ,body)
     (rec
     `(in-3d ,var (lambda (,var) . ,body))))
    (`(format ,str . ,args)
     (print (javascript-format-str str))
     (printf ".format(")
     (javascript-expressions args)
     (printf ")"))
    (`(attribute ,obj ,expr)
     (javascript-expression obj (operator-precedence 'attribute))
     (printf ".")
     (javascript-expression expr))
    (`(,fn . ,args)
     (javascript-call fn args))
    ((and (or `pi `pi/2 `pi/3 `pi/4 `pi/5 `pi/6
              `-pi `-pi/2 `-pi/3 `-pi/4 `-pi/5 `-pi/6
              `2*pi `3*pi `4*pi `5*pi `6*pi
              `-2*pi `-3*pi `-4*pi `-5*pi `-6*pi)
          p)
     (display p))
    ((and (or `2pi `3pi `4pi `5pi `6pi `3pi/2
              `-2pi `-3pi `-4pi `-5pi `-6pi `-3pi/2)
          p)
     (let* ((s (symbol->string p)))
       (printf (string-replace s "pi" "*pi"))))
    ((? number? x)
     (cond ((inexact? x)
            (display x))
           ((and (rational? x) (not (integer? x)))
            (rec `(/ ,(numerator x) ,(denominator x))))
           (else
            (display x))))
    ((? string? x)
     (if (string-contains? x "\'")
       (print x)
       (begin
         (display "'")
         (display x)
         (display "'"))))
    ((or #t `\#t) ;;to also handle latex
     (if (include-return?)
         (display "True")
         (display "pass")))
    ((or #f `\#f)
     (display "False"))
    ((and (or 'car 'cdr
              'caar 'cadr 'cdar 'cddr
              'caaar 'caadr 'cadar 'caddr 'cdaar 'cdadr 'cdddr
              'cadadr)
          fn)
     (rec `(lambda (l) (,fn l))))
    ((and (or '+ '- '* '/) fn)
     (rec `(lambda (a b) (,fn a b))))
    ((? symbol? x)
     (display (javascript-name x)))))

(define (javascript-expressions args)
  (cond ((null? args))
        (else
         (javascript-expression (car args))
         (for ((arg (cdr args)))
           (display ", ")
           (javascript-expression arg)))))

(define (javascript e [indent 0])
  (match e
    (`(define . ,body)
     (javascript-statement `(define . ,body)))
    (`(struct ,name ,fields)
     (printf "class ~A:~%" (javascript-name name))
     (let ((fields
            (map (lambda (field)
                   (match field
                     (`(,name : ,type) name)
                     (else name)))
                 fields)))
       (javascript-statement `(define (__init__ self ,@fields)
                            ,@(map (lambda (field)
                                     `(set! (attribute self ,field) ,field))
                                   fields))
                         4)))
    (else
     (javascript-statement e indent))))

(define-syntax-rule (py form ...) (begin (begin (javascript 'form) (newline)) ...))

(let ((args (current-command-line-arguments)))
  (for ((str (in-vector args)))
    (javascript
     (with-input-from-string str read))
    (newline)))

(define (javascript-str rkt #:return? [return? #t])
  (let ((so (open-output-string)))
    (parameterize ((current-output-port so)
                   (include-return? return?))
      (javascript rkt))
    (get-output-string so)))


